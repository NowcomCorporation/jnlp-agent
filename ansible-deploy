#!/bin/bash

ANSIBLE_VAULT_PASSWORD_FILE="playbook/.vault_password"
INVENTORY=$DEPLOY_INVENTORY
PLAYBOOK=$DEPLOY_PLAYBOOK
NAME=""
IMAGE=""
BASE_IMAGE=""
DEFAULT_BASE_IMAGE="nowcom/deploy"
ROLLBACK=""
REDEPLOY=""
DEBUG=""
ARGS=""
DRY_RUN=""
BUILD=""
REPO_VERSION=""
TAG=""
REPO=""
BUILD_FILE="ansible.build"
MODE=""

ENV_PLAYBOOK=""
VERSION="0.9.7"

function show-help {
  echo "
Deploys Ansible projects via a docker deployment container

Usage: ansible-deploy [--name <project>] [--inventory <inventory>] [--playbook <playbook>] [--repo-version <image tag> | --rollback | --redeploy ] [--debug | --dry-run] [args...]
       ansible-deploy --build [--name <project>] [--playbook <playbook>] [--image <image name>] [--config <filename>]

There are two modes with ansible-deploy:

   * build mode
   * deploy mode

Build mode builds a deployment container image with a version of the code and the ansible playbooks to deploy that code.
A deployment container image can be deployed via ansible-deploy on a machine that does not even have git, any of the source, or ansible installed.

Deploy mode takes a deployment container image and runs the ansible scripts to deploy it.
It supports rollback and redeploy.

Args:

  Build Mode
  ==========

    --build|-b
        Builds a specific deployment container for a specific project.
        Run this in the root of the project and use the --playbook arg to tell it which deploy file to include

    --name|-n <project>
        The name of the docker container to build that will be prefixed with the base image name. Default is "$DEFAULT_BASE_IMAGE"
        example: ansible-dws becomes $DEFAULT_BASE_IMAGE-ansible-dws
        If not supplied it will use the name of the current folder.

    --playbook|--play|-p <playbook>
        The playbook to deploy. If not provided the default is main.yml [See also Environment Variables below]

    --image|-image
        The base image used in creating the deployment container image. This is only used for a special cases when you need
        to base your deployment container image on another image instead of the default "$DEFAULT_BASE_IMAGE"

    --config|--config <file name>
        By default ansible-deploy will look for a file in the project root called ansible.deploy and will load up variables such as:

          name: # this along with the image is the name of the deployment container image. Can be overwritten with --name command line parameter
          image: # image to use as the base for the deployment container image. Can be overwritten with --image. Usually not needed since it defaults to $DEFAULT_BASE_IMAGE
          playbook: # The playbook to embed into the deployment container image. Can be overwrtten with --playbook command line parameter
          tag: # points to one of the names in the project section to determine which project's SHA to use as tag.
               #  if not supplied it defaults to using the SHA of the last project in the list

          projects: # list of repos to include in the deployment container image. There can be more than one set under this
            - name: # descriptive name of repo
              repo: # actual git repo
              path: # location on disk
              version: #(optional) SHA for the repo to git specific version

        This command line arg allows to load a different filename.


  Deploy Mode
  ===========

    --name|-n <project>
        The name of the docker image to deploy that is prefixed with the base image name. Default is "$DEFAULT_BASE_IMAGE"
        example: ansible-dws becomes $DEFAULT_BASE_IMAGE-ansible-dws
        If not supplied it will use the name of the current folder.

    --inventory|--inv|-i <inventory>
        Inventory sub folder to use in deployment [See also Environment Variables below]
        full inventory path is /etc/ansible/inventory/<inventory folder> and the base of the path is assumed.

    --playbook|--play|-p <playbook>
        The playbook to deploy. If not provided the default is main.yml [See also Environment Variables below]

    --repo-version|--SHA <SHA>
        Updates the source repo with a specific version of the code. This is the version tag of the image.
        When deploying and you don't supply this arg it will deploy the latest version.
        Must supply a minimum of 7 characters.

    --rollback
        Deploys the prior version.

    --redeploy
        Re-deploys the currently deployed version.

    --debug
        Drops you into a bash shell instead of running the ansible playbook

    --dry-run
        Does a dry-run of the play that outputs the variables, a list of tasks and runs the play without making changes

    args...
        Additional args you want to send along to ansible-playbook. example: --list-hosts

  Miscellaneous
  =============

    --help
        Show Help message

    --version
        Show version information

Environment Variables:

Some of the arugments can be set via environment variables which can be helpful when they might be the same or repeated everytime.
Like when deploying from a production deployer machine you always want to deploy the prod inventory.

   DEPLOY_INVENTORY

example:

$> export DEPLOY_INVENTORY=prod

$> ansible-deploy myproject


ansible-deploy Installation
===========================
docker run -it --rm --volume $HOME/.local/bin:/target nowcom/ansible-deploy

This will run a special docker container that will install ansible-deploy to a directory on your local machine.
$HOME/.local/bin above maps to /target internally in the container so the ansible-deploy file will be copied to your 
local $HOME/.local/bin which should by on your path.

You can confirm this by:

ansible-deploy --version

It should run and show version same as what the container said it deployed.

"
  return 0
}

function parse_build_file {
BUILD_FILE="$1" ATTRIBUTE="$2" python - <<END
import yaml
import os
import sys

class DevNull:
    def write(self, msg):
        pass

sys.stderr = DevNull()

stream = file(os.environ['BUILD_FILE'], 'r')
yml=yaml.load(stream)
print yml[os.environ['ATTRIBUTE']]
END
}

function build-image {
  MODE="Build"
  PROJECTS=""
  DEPLOY_VERSION=""

  # load config file if any for processing
  if [ -e "$BUILD_FILE" ]; then
    OLDIFS=$IFS
    [[ -z $NAME ]] && NAME=$(parse_build_file "$PWD/$BUILD_FILE" "name")
    [[ -z $BASE_IMAGE ]] && BASE_IMAGE=$(parse_build_file "$PWD/$BUILD_FILE" "image")
    [[ -z $PLAYBOOK ]]  && PLAYBOOK=$(parse_build_file "$PWD/$BUILD_FILE" "playbook")
    [[ -z $TAG_NAME ]] && TAG_NAME=$(parse_build_file "$PWD/$BUILD_FILE" "tag")
    IFS='}' read -a PROJECTS <<<$(parse_build_file "$PWD/$BUILD_FILE" "projects" | tr -d '[{]' | sed -r "s/': '/:/g" | sed -r "s/', '/!/g" | tr -d "," | sed -r "s/ /_/g" | sed -r "s/!/ /g" | sed -e "s/_'//" | tr -d "'" )
    IFS=$OLDIFS
  fi

  # if NAME is not given via command line or config file then default to the dir name
  [[ -z $NAME ]] && NAME=`basename $(pwd)`

  # if PLAYBOOK is not given via command line or config file then default to main.yml
  [[ -z $PLAYBOOK ]] && PLAYBOOK="main.yml"

  # if BASE_IMAGE is not given via command line or config file then default to DEFAULT_BASE_IMAGE
  [[ -z $BASE_IMAGE ]] && BASE_IMAGE=$DEFAULT_BASE_IMAGE

  echo
  echo "Building $BASE_IMAGE-$NAME deployment container"

  # make sure .ansible-deploy folder is in .gitignore so we dont push to repo
  touch .gitignore && grep -q -F '.ansible-deploy/' .gitignore || echo '.ansible-deploy/' >> .gitignore

  # prepare .ansible-deploy folder
  mkdir -p .ansible-deploy/playbook
  rsync -aqv . .ansible-deploy/playbook --exclude .ansible-deploy
  cp $HOME/.vault_password .ansible-deploy/playbook/

  # clear the directory stack and start fresh
  dirs -c
  pushd .ansible-deploy >/dev/null 2>&1
  touch .dockerignore && grep -q -F '**/.git' .dockerignore || echo '**/.git' >> .dockerignore
  grep -q -F '**/.gitignore' .dockerignore || echo '**/.gitignore' >> .dockerignore
  grep -q -F 'Dockerfile' .dockerignore || echo 'Dockerfile' >> .dockerignore
  grep -q -F '**/.dockerignore' .dockerignore || echo '**/.dockerignore' >> .dockerignore
  grep -q -F $BUILD_FILE .dockerignore || echo $BUILD_FILE >> .dockerignore
  popd >/dev/null 2>&1

  if [[ -n $PROJECTS ]]; then
    OLDIFS=$IFS
    for line in "${PROJECTS[@]}"; do
      name=""
      repo=""
      path=""
      version=""
      IFS=' ' read -r -a items <<< "$line"
      for item in "${items[@]}"; do
        [[ $item =~ "name:" ]] && name=${item:5}
	[[ $item =~ "repo:" ]] && repo=${item:5}
        [[ $item =~ "path:" ]] && path=${item:6}
        [[ $item =~ "version:" ]] && version=${item:8}
      done

      if [[ -n $name ]]; then
        name=$(echo $name | sed -r "s/_/ /g")
        echo -n "Building in $name "
      fi

      # update source repo
      if [[ -n $path ]]; then
        base=`basename $path`
        dir=`dirname $path`

        pushd .ansible-deploy >/dev/null 2>&1
        mkdir -p $dir >/dev/null 2>&1
        if [ -e $path/.git ]; then
          pushd $path >/dev/null 2>&1
          if [[ -n $version ]]; then
            REPO_VERSION=$(git rev-parse $version)
            git reset --quiet --hard $REPO_VERSION
          else
            git fetch --all --quiet
            git reset --hard origin/master --quiet
          fi
          popd >/dev/null 2>&1
        else
          if [[ -n $repo ]]; then
            pushd $dir >/dev/null 2>&1
            git clone $repo $base/
            popd >/dev/null 2>&1
          fi
        fi
        popd >/dev/null 2>&1
      fi

      [[ -n $path ]] && pushd .ansible-deploy/$path >/dev/null 2>&1

      # Make sure we have the full SHA
      REPO_VERSION=$(git rev-parse HEAD)

      if [ "$TAG_NAME" = "$name" ] || [[ -z $TAG_NAME ]]; then
        TAG=":${REPO_VERSION:0:7}"
      fi

      [[ -n $path ]] && popd >/dev/null 2>&1

      DEPLOY_VERSION="$DEPLOY_VERSION  $name: $REPO_VERSION\n"
      echo "Version: $REPO_VERSION"
    done

    IFS=$OLDIFS
  fi

  pushd .ansible-deploy >/dev/null 2>&1
  # Build Dockerfile
  user=$(git config --get user.name)
  email=$(git config --get user.email)
  [[ -z $user ]] && user="devops"
  [[ -z $email ]] && email="devops@nowcom.com"

  cat > Dockerfile <<EOF
FROM $BASE_IMAGE
LABEL maintainer="$user <$email>"
LABEL ansible-deploy-version="$VERSION"

COPY . /

ENV DEPLOY_PLAYBOOK "$PLAYBOOK"
ENV DEPLOY_VERSION "$DEPLOY_VERSION"
ENV ANSIBLE_VAULT_PASSWORD_FILE "$ANSIBLE_VAULT_PASSWORD_FILE"
EOF

  # Build the image TAG with source version SHA (short)
  # Then tag it "latest"
  LATEST=":latest"
  docker build -t $BASE_IMAGE-$NAME$TAG .
  docker tag $BASE_IMAGE-$NAME$TAG $BASE_IMAGE-$NAME$LATEST
  docker image prune -f

  popd >/dev/null 2>&1
}

function deploy-image {
  MODE="Run"
  RETURNCODE=0
  DEPLOYED_IMAGE=""
  CURRENT_IMAGE=""

  echo
  echo "Deploying $BASE_IMAGE-$NAME deployment container"
  echo
  echo "Image: $IMAGE"
  echo "Project name: $NAME"
  echo "Inventory file: $INVENTORY"
  [[ "$TAG" == "" ]] && { echo "Repo Version: latest"; } || { echo "Repo Version: ${TAG:1}"; }

  if [[ -z $INVENTORY ]]; then
    echo
    echo "Inventory file is required. You need to use the --inventory argument or set DEPLOY_INVENTORY environment variable"
    return 1
  fi

  ROLLBACK=":rollback-$INVENTORY"
  DEPLOYED=":deployed-$INVENTORY"

  [[ -n $DRY_RUN ]] && echo -e "\nDRY-RUN: No changes will be made during this deployment\n"

  DEPLOYED_IMAGE=$(docker images --quiet $BASE_IMAGE-$NAME$DEPLOYED)

  [[ ! "$IMAGE" =~ ":" ]] && TAG=":latest"
  CURRENT_IMAGE=$(docker images --quiet $IMAGE$TAG)

  # Run the deploy container
  # if Dry-run start with displaying a list of the tasks that will be run
  [[ -n $DRY_RUN ]] && docker run -it --rm --name deploy-$NAME-${TAG:1} --user=devops --volume=/home/devops:/home/devops $ENV_PLAYBOOK $IMAGE $cmd --list-tasks
  docker run -it --rm --name deploy-$NAME-${TAG:1} --user=devops --volume=/home/devops/.ssh:/home/devops/.ssh $ENV_PLAYBOOK $IMAGE $cmd
  RETURNCODE="$?"

  if [[ -z $DRY_RUN ]] && [ "$RETURNCODE" -eq 0 ] && [ "$DEBUG" = "" ] && [ "$REDEPLOY" = "" ] && [ "$CURRENT_IMAGE" != "$DEPLOYED_IMAGE" ]; then
    # Tag the image with latest
    docker tag $IMAGE $BASE_IMAGE-$NAME$DEPLOYED

    # Tag previously deployed with rollback
    if [ "$DEPLOYED_IMAGE" != "" ]; then
      docker tag $DEPLOYED_IMAGE $BASE_IMAGE-$NAME$ROLLBACK
    fi
  fi

  return $RETURNCODE
}

function display-time {
  END=$(date +%s)
  duration=$((END-START))
  minutes=$((duration / 60))
  seconds=$((duration % 60))

  echo ""
  echo -n $MODE"time: "
  [ $minutes -gt 0 ] && { [ $minutes -eq 1 ] && { echo -n "$minutes minute and "; } || { echo -n "$minutes minutes and "; }; }
  echo -n "$seconds"
  [ $seconds -eq 1 ] && { echo " second"; } || { echo " seconds"; }
  echo
}

function show-version {
  echo "ansible-deploy $VERSION"
  IMAGE_EXISTS=$(docker images --quiet $BASE_IMAGE-$NAME)
  [ "$IMAGE_EXISTS" != "" ] && echo "  Image: $BASE_IMAGE-$NAME" && echo "  Project name: $NAME"
  echo -n "  DEPLOY_INVENTORY: " && [ "$DEPLOY_INVENTORY" != "" ] && echo "$DEPLOY_INVENTORY" || echo "<NOT SET>"

  return 0
}

## MAIN
START=$(date +%s)

if [ $# -lt 1 ]; then
  show-help
  exit 0
fi

# Evaluate command line arguments
while [ $# -gt 0 ]; do
key="$1"

case $key in
    -install|--install)
      cp /ansible-deploy /target/ansible-deploy
      chown ${LOGNAME}:${LOGNAME} /target/ansible-deploy
      echo
      echo "Installed ansible-deploy $VERSION"
     exit 0
    ;;
    -name|--name|-n)
      NAME="$2"
      shift
    ;;
    -inv|--inv|-i|-inventory|--inventory)
      INVENTORY="$2"
      shift
    ;;
    -playbook|--playbook|-p|-play|--play)
      PLAYBOOK="$2"
      shift
    ;;
    -image|--image)
      $BASE_IMAGE=$2
      shift
    ;;
    -config|--config)
      BUILD_FILE=$2
      shift
    ;;
    # always in front of repo-version since it resets vars and repo-version is
    # used in build and deploy modes while rollback only in deploy
    -rollback|--rollback)
      ROLLBACK="YES"
      REPO_VERSION=""
      TAG=":rollback"
    ;;
   -redeploy|--redeploy)
      REDEPLOY="YES"
      REPO_VERSION=""
      TAG=":deployed"
    ;;
    -repo-version|--repo-version|-SHA|--SHA|--sha|-sha)
      REPO_VERSION="$2"
      TAG=":${REPO_VERSION:0:7}"
      shift
    ;;
    -debug|--debug)
      DEBUG="/bin/bash"
    ;;
    -dry-run|--dry-run)
      DRY_RUN="YES"
    ;;
    -build|--build|-b)
      BUILD="YES"
    ;;
    -repo|--repo|-r)
      REPO="$2"
      shift
    ;;
    -help|--help|-h)
      show-help
      exit 0
    ;;
    -version|--version)
      show-version
      exit 0
    ;;
    *)
    ARGS="$*"
    break
    ;;
 esac

shift
done

if [ $# -eq 1 ] && [[ ! $1 =~ ^- ]]; then
  NAME=$1
  shift
fi

# Building a docker image by creating the Dockerfile and then building it
if [ "$BUILD" = "YES" ]; then
  if [ "$ROLLBACK" = "YES" ] || [ "$REDEPLOY" = "YES" ] || [ "$DEBUG" != "" ]; then
    echo "Error: Cannot use --rollback, --redeploy or --debug with --build"
    echo
    echo "Usage:"
    echo "ansible-deploy --build [--name project] [--playbook <playbook>] [--config filename]"
    echo
    echo "use ansible-deploy --help for more information"
    exit 1
  fi

  build-image
  display-time
  exit 0
fi

if [ "$TAG" = ":rollback" ] || [ "$TAG" = ":deployed" ]; then
  TAG="$TAG-$INVENTORY"
fi

[[ -z $NAME ]] && NAME=`basename $(pwd)`

if [[ -n $NAME ]]; then
  [[ -z $BASE_IMAGE ]] && BASE_IMAGE=$DEFAULT_BASE_IMAGE
  IMAGE="$BASE_IMAGE-$NAME"

  # Does this image already exist?
  IMAGE_EXISTS=$(docker images $BASE_IMAGE-$NAME | grep $NAME)
  if [ "$IMAGE_EXISTS" ]; then
    IMAGE="$BASE_IMAGE-$NAME$TAG"
  fi
fi

# If a playbook is not supplied then use main.yml as default
if [[ -n $PLAYBOOK ]]; then
  ENV_PLAYBOOK="-e=DEPLOY_PLAYBOOK=$PLAYBOOK"
else
  ENV_PLAYBOOK=""
fi

# Make sure we take the last directory if a full path is given
if [[ -n $INVENTORY ]]; then
  INVENTORY=`basename $INVENTORY`
fi

cmd="ansible-playbook -i /etc/ansible/inventory/$INVENTORY $ARGS"
if [[ -n $DEBUG ]]; then
  cmd="/bin/bash"
fi

deploy-image
display-time

exit 0

